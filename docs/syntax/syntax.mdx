
# Syntax
## How to write snapblocks
Snapblocks is written how you see it in Snap<i>!</i>, with each block on a new line.

```snapblocks
when flag clicked
move (10) steps
say [Hello world!]
```

<SnapBlocks>
  {`
    when flag clicked
    move (10) steps
    say [Hello world!]
  `}
</SnapBlocks>

There are of course different block shapes that you can use.

```snapblocks
command
(reporter)
<predicate>
```

<SnapBlocks>
{`
command
(reporter :: obsolete)
<predicate>
`}
</SnapBlocks>

You can set more shapes with overrides

```snapblocks
hat :: hat
cap :: cap
```

<SnapBlocks>
{`
hat :: hat
cap :: cap
`}
</SnapBlocks>

However there are some blocks that will automatically become that shape.

```snapblocks
when flag clicked
stop [all V]
```

<SnapBlocks>
{`
when flag clicked
stop [all V]
`}
</SnapBlocks>

Anything after `::` is used to define properties about the block, such as it's shape, and more.

## C-shapes

C-shapes are created using curly braces.

```snapblocks
if <> {
  
} @addInput
```

<SnapBlocks>
{`
if <> {
  
} @addInput
`}
</SnapBlocks>

Anything inside the curly braces are placed in the c-shape.

```snapblocks
if <> {
  move (10) steps
} @addInput
```

<SnapBlocks>
{`
if <> {
  move (10) steps
} @addInput
`}
</SnapBlocks>

## Inputs

As you probably noticed, there are inputs inside blocks, these are:

```snapblocks
number (5)
string [strng]
boolean <>
```

<SnapBlocks>
{`
number (5)
string [strng]
boolean <>
`}
</SnapBlocks>

### Number Input

A number input is created by using parentheses `()`. A number input can only have number in it.

```snapblocks
number (5)
```

<SnapBlocks>
{`
number (5)
`}
</SnapBlocks>

### String Input

A string input is created by using square brackets `[]`. A string input can have any text in it.

```snapblocks
say [Hello world!]
```

<SnapBlocks>
{`
say [Hello world!]
`}
</SnapBlocks>

String inputs can also be larger (without any text). Just wrap the value inside with curly brackets.

```snapblocks
(first word of [{}] :: operators)
(first word of [{hi}] :: operators)
```

<SnapBlocks>
{`
(first word of [{}] :: operators)
(first word of [{hi}] :: operators)
`}
</SnapBlocks>

These curly brackets also go around a dropdown `v` (although it's about the same size with an empty normal dropdown input').

```snapblocks
(text input dropdown [{hi v}] :: operators)
```

<SnapBlocks>
{`
(text input dropdown [{hi v}] :: operators)
`}
</SnapBlocks>

### Dropdowns

Dropdowns can be created by putting a `v` right before the closing bracket in inputs. There are 2 types of dropdowns, editable `v`, and read-only `V`.

```snapblocks
editable bumber (5 v)
editable string [string v]
read-only (5 V)
read-only [string V]
```

<SnapBlocks>
{`
editable bumber (5 v)
editable string [string v]
read-only (5 V)
read-only [string V]
`}
</SnapBlocks>

Number dropdowns can have anything in it.

```snapblocks
(item (last v) of @list)
```

<SnapBlocks>
{`
(item (last v) of @list)
`}
</SnapBlocks>

### Formatting

You can also format string and number inputs to make them italic or monospace.
Just wrap the text in the slot with square brackets `[]` for italics, and backticks for monospace ```.
The formatting does not go around the ` v` in inputs with dropdowns.

```snapblocks
(item ([last] v) of @list)
(JavaScript function \( @addInput \)) \{ [`code`] \}
```

<SnapBlocks>
{`
(item ([last] v) of @list)
(JavaScript function \\( @addInput \\) \\{ [\`code\`] \\} )
`}
</SnapBlocks>

There is also a special value that can be used inside inputs, `[__shout__go__]`, which turns into a green flag.

```snapblocks
broadcast [[__shout__go__] V] @addInput
```

<SnapBlocks>
{`
broadcast [[__shout__go__] V] @addInput
`}
</SnapBlocks>

### Color Input

Color inputs are created by putting a color code inside a string or number input. A color code can either by a hex color code, or an rgb value.

```snapblocks
<touching [#911a44] ?>
<touching [rgb(145,26,68)] ?>
<touching (#911a44) ?>
```

<SnapBlocks>
{`
<touching [#911a44] ?>
<touching [rgb(145,26,68)] ?>
<touching (#911a44) ?>
`}
</SnapBlocks>

Currently, as of snapblocks 1.4.0, an rgb color cannot be used inside number inputs.

### Boolean Input

A Boolean input is created by using angled brackets `<>`.

```snapblocks
Boolean <>
```

<SnapBlocks>
{`
Boolean <>
`}
</SnapBlocks>

A Boolean input can only have some specific values, which are used to choose whether the input is true or false.

```snapblocks
true <t>
false <f>
```

<SnapBlocks>
{`
true <t>
false <f>
`}
</SnapBlocks>

However, you can also use the static (bigger) Boolean input.

```snapblocks
true <true>
false <false>
```

<SnapBlocks>
{`
true <true>
false <false>
`}
</SnapBlocks>

If you create a predicate with only a Boolean input that is either a static true or false, it will automatically be set to the Boolean block in Snap<i>!</i>

```snapblocks
<<true>>
<<false>>
```

<SnapBlocks>
{`
<<true>>
<<false>>
`}
</SnapBlocks>

## Upvars

Upvars are created by putting another set of parentheses around a variable, like so.

```snapblocks
script variables ((upvar)) @addInput
```

<SnapBlocks>
{`
script variables ((upvar)) @addInput
`}
</SnapBlocks>

## Categories

Categories are automatically set for blocks that are in Snap<i>!</i>, or Scratch. However, you can manually set the category for any block. To set the category, put the category name after `::`.

```snapblocks
motion :: motion
looks :: looks
sound :: sound
pen :: pen
control :: control
sensing :: sensing
operators :: operators
variables :: variables
lists :: lists
other :: other
```

<SnapBlocks>
{`
motion :: motion
looks :: looks
sound :: sound
pen :: pen
control :: control
sensing :: sensing
operators :: operators
variables :: variables
lists :: lists
other :: other
`}
</SnapBlocks>

This is not an exhaustive list of all the Categories available in snapblocks, but it's the main Categories used in Snap!

It is also possible to create custom colors, by using either a hex color code, or an rgb color code.

```snapblocks
custom :: #3a5f75
custom :: rgb(255, 100, 50)
```

<SnapBlocks>
{`
custom :: #3a5f75
custom :: rgb(255, 100, 50)
`}
</SnapBlocks>

## Icons

Icons are created by putting either a `@` sign, or a `$` sign before the icon name.

```snapblocks
pause all @pause
pause all $pause
```

<SnapBlocks>
{`
pause all @pause
pause all $pause
`}
</SnapBlocks>

### Icon and text scale and color

You can change the scale and color of icons by adding `-scale-r-g-b` at the end of the icon name.

```snapblocks
@flag-2-255-100-2 :: other
```

<SnapBlocks>
{`
@flag-2-255-100-2 :: other
`}
</SnapBlocks>

You can also change the scale and color of text using this system, only you have to put the text after `$`, not `@`.

```snapblocks
$text-2-200-200-100
```

<SnapBlocks>
{`
\$text-2-200-200-100
`}
</SnapBlocks>

### list of icons
Here's a list of all available icons.

<SnapBlocks>
{`
greenflag @greenflag :: other
greenFlag @greenFlag :: other
flag @flag :: other
stopSign @stopSign :: other
stop @stop :: other
octagon @octagon :: other
turnLeft @turnLeft :: other
turnRight @turnRight :: other
clockwise @clockwise :: other
counterclockwise @counterclockwise :: other
loop @loop :: other
loopArrow @loopArrow :: other
addInput @addInput :: other
delInput @delInput :: other
verticalEllipsis @verticalEllipsis :: other
list @list :: other
pointRight @pointRight :: other
turtle @turtle :: other
turtleOutline @turtleOutline :: other
pause @pause :: other
cloud @cloud :: other
cloudGradient @cloudGradient :: other
cloudOutline @cloudOutline :: other
flash @flash :: other
blitz @blitz :: other
camera @camera :: other
circleSolid @circleSolid :: other
circle @circle :: other
ellipse @ellipse :: other
notes @notes :: other
storage @storage :: other
brush @brush :: other
pipette @pipette :: other
paintbucket @paintbucket :: other
bucket @bucket :: other
eraser @eraser :: other
location @location :: other
gears @gears :: other
gearPartial @gearPartial :: other
gearBig @gearBig :: other
globe @globe :: other
globeBig @globeBig :: other
square @square :: other
robot @robot :: other
stepForward @stepForward :: other
file @file :: other
fullScreen @fullScreen :: other
grow @grow :: other
normalScreen @normalScreen :: other
shrink @shrink :: other
smallStage @smallStage :: other
normalStage @normalStage :: other
stage @stage :: other
turnAround @turnAround :: other
poster @poster :: other
tick @tick :: other
checkedBox @checkedBox :: other
rectangle @rectangle :: other
rectangleSolid @rectangleSolid :: other
dot @dot :: other
line @line :: other
cross @cross :: other
crosshairs @crosshairs :: other
speechBubble @speechBubble :: other
speechBubbleOutline @speechBubbleOutline :: other
turnBack @turnBack :: other
turnForward @turnForward :: other
magnifyingGlass @magnifyingGlass :: other
magnifierOutline @magnifierOutline :: other
selection @selection :: other
polygon @polygon :: other
closedBrush @closedBrush :: other
footprints @footprints :: other
keyboard @keyboard :: other
keyboardFilled @keyboardFilled :: other
listNarrow @listNarrow :: other
flipVertical @flipVertical :: other
flipHorizontal @flipHorizontal :: other
trash @trash :: other
trashFull @trashFull :: other
arrowUp @arrowUp :: other
arrowUpOutline @arrowUpOutline :: other
arrowUpThin @arrowUpThin :: other
arrowDown @arrowDown :: other
arrowDownOutline @arrowDownOutline :: other
arrowDownThin @arrowDownThin :: other
arrowLeft @arrowLeft :: other
arrowLeftOutline @arrowLeftOutline :: other
arrowLeftThin @arrowLeftThin :: other
arrowRight @arrowRight :: other
arrowRightOutline @arrowRightOutline :: other
arrowRightThin @arrowRightThin :: other
arrowUpDownThin @arrowUpDownThin :: other
arrowLeftRightThin @arrowLeftRightThin :: other
`}
</SnapBlocks>

## Rings

There are rings in Snap<i>!</i>, so it's possible to create rings in snapblocks.

```snapblocks
({} @addInput)
(() @addInput)
(<> @addInput)
```

<SnapBlocks>
{`
({} @addInput)
(() @addInput)
(<> @addInput)
`}
</SnapBlocks>

You can put any block inside the first input, as long as it fits the shape.

```snapblocks
({move (10) steps} @addInput)
((x position) @addInput)
(<shown?> @addInput)
```

Now, since rings can contain scripts of multiple blocks, it's very much possible to do that here.

```snapblocks
({move (10) steps
  say [Hello!]} @addInput)
```

<SnapBlocks>
{`
({move (10) steps
  say [Hello!]} @addInput)
`}
</SnapBlocks>

Rings can also have input names

```snapblocks
({} input names: ((#1)) ((#2)) @delInput @addInput)
```

<SnapBlocks>
{`
({} input names: ((#1)) ((#2)) @delInput @addInput)
`}
</SnapBlocks>

## Alternate block labels

Some blocks have alternate ways of writing them.

```snapblocks
when @greenFlag clicked
when flag clicked
when gf clicked
when green flag clicked

turn @clockwise (15) degrees
turn @turnRight (15) degrees
turn cw (15) degrees
turn right (15) degrees

turn @counterclockwise (15) degrees
turn @turnLeft (15) degrees
turn ccw (15) degrees
turn left (15) degrees

pause all @pause
pause all
```

<SnapBlocks>
{`
when @greenFlag clicked
when flag clicked
when gf clicked
when green flag clicked

turn @clockwise (15) degrees
turn @turnRight (15) degrees
turn cw (15) degrees
turn right (15) degrees

turn @counterclockwise (15) degrees
turn @turnLeft (15) degrees
turn ccw (15) degrees
turn left (15) degrees

pause all @pause
pause all
`}
</SnapBlocks>

There are some blocks that also have some special symbols in them that aren't on most keyboards, so there are some shortcuts

```snapblocks
<[] ≤ [] @delInput @verticalEllipsis @addInput>
<[] \<= [] @delInput @verticalEllipsis @addInput>

<[] ≥ [] @delInput @verticalEllipsis @addInput>
<[] \>= [] @delInput @verticalEllipsis @addInput>

(atan2 () ÷ ())
(atan2 () / ())

(() × () @delInput @verticalEllipsis @addInput)
(() x () @delInput @verticalEllipsis @addInput)
```

The backslash is important because it tells snap to not close the block.

<SnapBlocks>
{`
  <[] ≤ []>
  <[] \\<= []>

  <[] ≥ []>
  <[] \\>= []>

  (atan2 () ÷ ())
  (atan2 () / ())

  (() × () @delInput @verticalEllipsis @addInput)
  (() x () @delInput @verticalEllipsis @addInput)
`}
</SnapBlocks>

## Define block

Custom blocks are an essential part of Snap<i>!</i>, formerly known as BYOB, Build Your Own Blocks.

### Snap<i>!</i> block prototype

The Snap<i>!</i> block prototype (or some might say, define block) is created as such.

```snapblocks
{+ custom + block +} :: define
```

<SnapBlocks>
{`
{+ custom + block +} :: define
`}
</SnapBlocks>

The plus signs are optional, but are what Snap<i>!</i> has by default. If you don't want to type in the plus signs manually, you can use `:: define+` instead.

```snapblocks
{+ custom + block +} :: define+
```

<SnapBlocks>
{`
{+ custom + block +} :: define+
`}
</SnapBlocks>

When you define a block, you can use any shape or category, and the block will be automatically detected if used later (except it won't set the shape).

```snapblocks
<predicate :: motion> :: define+

<predicate>
```

<SnapBlocks>
{`
<predicate :: motion> :: define+

<predicate>
`}
</SnapBlocks>

Custom blocks can have inputs, which can be added by adding upvars, the same way that they are shown in Snap<i>!</i>

```snapblocks
{block ((string)) ((number #)) ((boolean ?)) ((default = hi)) :: looks} :: define+

block [string] (5) <> [hi]
```

<SnapBlocks>
{`
{block ((string)) ((number #)) ((boolean ?)) ((default = hi)) :: looks} :: define+

block [string] (5) <> [hi]
`}
</SnapBlocks>

You can also set inputs using their input syntax.

```snapblocks
{block [string] (number) <boolean> :: looks} :: define+

block [string] (5) <>
```

<SnapBlocks>
{`
{block [string] (number) <boolean> :: looks} :: define+

block [string] (5) <>
`}
</SnapBlocks>

### Scratch define

The Scratch define block can be created by typing the word `define` then the custom block withing curly brackets.

```snapblocks
define {custom block [string] (number) <boolean>}

custom block [] () <>
```

<SnapBlocks blockStyle="scratch2">
{`
define {custom block [string] (number) <boolean>}

custom block [] () <>
`}
</SnapBlocks>

## Multiline blocks

Snap<i>!</i> allows for placing newlines in blocks, which can be created like so.

In a command block, you have to either place a backslash `\` before a newline, or use `\n`.

```snapblocks
multiline \
block \n cool
```

<SnapBlocks>
{`
multiline \
block \\n cool
`}
</SnapBlocks>

Reporters and predicates are easier, because you can just hit enter.

```snapblocks
(multiline
 reporter)
<multiline
 predicate>
```

<SnapBlocks>
{`
(multiline
 reporter)
<multiline
 predicate>
`}
</SnapBlocks>

However, you cannot put multiple inputs vertically on the same line, like in the <SnapBlocks inline="true">{`(pipe [] @arrowRight (() @addInput) @delInput @verticalEllipsis @addInput)`}</SnapBlocks> block.

## Multiline input

As you may know, you can create a multiline input in Snap<i>!</i> Thankfully it's similar to creating multiline reporters and predicates.

```snapblocks
multiline [multiline
text]
```

<SnapBlocks>
{`
multiline [multiline
text]
`}
</SnapBlocks>

Make sure not to indent multiline inputs, as all spaces are shown within an input.

## Comments

Comments can be added on blocks or by itself, by typing `//` and then the comment text.

```snapblocks
// Comment
block // comment
```

<SnapBlocks>
{`
// Comment
block // comment
`}
</SnapBlocks>

You can create multiline comments by enclosing it within `/* text */`.

```snapblocks
/* multiline
comment */
multiline /* block
with comment */
```

<SnapBlocks>
{`
/* multiline
comment */
multiline /* block
with comment */
`}
</SnapBlocks>
